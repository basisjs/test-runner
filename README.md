# Basis.js test runner

## Что это?

Это "еще один" исполнитель модульных тестов (unit-test runner).

В основном он расчитан на тестирование фреймворка `basis.js`, а так же проектов, разрабатываемых с его применением. В этом случае можно воспользоваться преимуществами модульной системы фреймворка. Но это не является обязательным требованием и runner может использоваться в проектах без него.

Ключевыми особенностями являются атоматическое обновление тестов и их прогон при изменении тестируемого кода (не требуется самостоятельно обновлять страницу), а так же более человекопонятная информация о результатах прохождения теста, нежели в других тестирующих решениях.

На данный момент, реализован лишь базовый функционал и запуск тестов возможен только в браузере. В будущем возможности будут расширяться (см. [TODO](todo)), ускоряя и упрощая процесс модульного тестирования.

## Как использовать

Чтобы использовать runner, нужно добавить в проект сборку reporter'а и настроить его использование.

### Установка

Команды для локальной установки нужно скопировать файлы из папки `build` этого репозитория в проект, где планируется использование, например, в папку `test/runner`.

### Сборка

Если необходимо сделать сборку, то для этого нужны инструменты [`basisjs-tools`](https://github.com/basisjs/basisjs-tools). Полный список команд:

    > git clone https://github.com/basisjs/test-runner.git
    > cd test-runner
    > bower install
    > basis build

После выполнения этих команд, результат сборки окажется в папке `build`.

### Использование в проекте

Когда сборка reporter'а добавлена в проект, нужно настроить его использование. В данном репозитории, можно найти примеры настройки для проектов на `basis.js` [example/basis_setup](example/basis_setup) и для проектов без него - [example/non_basis_setup](example/non_basis_setup). Можно скопировать содержимое из нужной папки в папку `test` проекта. Если в ней находится папка `runner`, то больше ничего менять не нужно (только в настройке для `basis.js` нужно изменить путь к основному файлу фреймворка).

Основное отличие настроек в том, что в случае `basis.js` набор тестов можно разбить на множество файлов, а в случае изменении тестов или тестируемого кода тесты будут самостоятельно перезапускаться. Без `basis.js` всего этого не будет.

Для запуска тестов (пока только в браузере), в браузере нужно открыть папку `test`, например, так `http://localhost/test` (адрес может быть другим, в зависимоти от ваших настроек). При открытии адреса сделается перенаправление на `reporter` и откроется его интерфейс. Останется только нажать кнопку `Run` в правом верхнем углу, чтобы запустить выполнение тестов.

[Пример использования](https://github.com/basisjs/basisjs/tree/master/test) можно посмотреть в репозитории `basis.js`, выглядит это так:

![Как выглядит](https://github.com/basisjs/test-runner/tree/master/docs/img/example.png)

## TODO

- придумать номальное название :)
- сделать что test runner полностью тестировал сам себя
- доделать стиль
- выводить в summary не только ошибки, но информацию об общем ходе выполнения тестов
- beforeEach/afterEach (+done/async)
- возможность задавать порог, что тест медленно отрабатывает
- возможность быстрой отладки
- возможность делать тесты производительности
- возможность использовать различные assert библиотеки
- добавить различные интерфейсы: bdd, tdd, exports, qunit
- автоматизивароть сборку и зарегистрировать в bower
- прогон тестов используя node.js (зарегистрировать в npm)
- поддержка code coverage
- интеграция с travis ci

## Описание тестов

Тесты описываются в виде вложенной структуры из объектов и массивов. Важными полями являются `name` и `test`. Первое задает подпись к тесту (название), а второе - либо сам тест, либо набор вложенных тестов.

```js
var myTestSuite = {
  name: 'Test suite',
  test: [
    {
      name: 'Test #1',
      test: function(){
        // test code
      }
    },
    {
      name: 'Test #2',
      test: function(){
        // test code
      }
    }
  ]
};
```

Если значением поля `test` является функция, то это сам тест. Если массив, то набор тестов (`suite`).

Если используется [`basis.js`](https://github.com/basisjs/basisjs), то тесты и их наборы можно выносить в отдельные файлы используя функцию `require`. Это облегчает навигацию по тестам.

Обычно описывается корневой пакет тестов (`index.js`), который выглядит вот так:

```js
// test suite
module.exports = {
  name: 'RNA test suite',
  html: __dirname + 'env.html', // базовый файл окружения
  test: [
    require('./spec/suite1.js'),
    require('./spec/suite2.js'),
    require('./spec/suite3.js'),
    require('./spec/suite4.js')
  ]
};
```

Этот файл подключает другие файлы, являясь своего рода входной точкой. Тесты описываются в отдельных файлах и, обычно, располагаются в папке `spec`.

Свойство `html` задает файл, который будет использоваться для задания окружения. Такой файл загружается в `iframe`, а код тестов выполняется в рамках этого фрейма. Значение этого свойства наследуется вложенными тестами, потому не нужно его задавать без необходимости.

Типовой пакет (`suite`) выглядит так:

```js
module.exports = {
  name: 'Test suite',
  init: function(){
    // ...
  },
  test: [
    // тесты
  ]
};
```

Свойство `init` является необязательным и позволяет задать функцию инициализирующее окружение. Этот код будет выполнен один единственный раз в момент инициализации, перед выполнением первого теста. Нужно иметь ввиду, что код этой функции выполняется в отдельном окружении (в отдельном `iframe`), и потому у него будет область видимости отличная от той, в которой описывается сама функция. То же касается и самих тестов.

Переменные объявленные в `init` будут доступны всем тестам. В упрощеном виде это работает так:

```js
eval(getFunctionBody(testSuite.init));

function runTest(code){
  eval(getFunctionBody(code));
}

runTest(test1);
runTest(test2);
...
```

Если у теста (или набора) есть свойство `html` или `init`, то для него и его вложенных тестов создается собственное окружение (отдельный `iframe`).

### Утверждения

В тестах выполняемый код должен сопровождаться утверждениями (`assertion`). Для проверки утверждения используется функция `assert`, которая доступна любому тесту как локальная переменная. Функция может принимать от одного до двух аргументов:

```js
assert(actual);                  // проверяется, что значение правдиво, то есть
                                 // не равно '' (пустая строка), null, undefined, false, 0 и NaN
assert(expected, actual);        // проверяется, что actual равно expected
assert.deep(expected, actual);   // глубокая проверка, что actual равно expected
```

Здесь `actual` это проверяемое значение, а `expected` - то значение которое ожидается.

При сравнении `expected` и `actual` делается проверка соотвествия типов и значений. Если тип совпадает, и этот тип массив или объект, то делается не четкое сравнение значений, а их похожесть: все ключи и значения тождественно равны (`===`). Для применения того же правила к вложенным значением используется функция `assert.deep(expected, actual)`.

Если для проверки значения достаточно использовать операторы `===` или `==`, то такое выражение можно записать единственным аргументом `assert`. Test runner поймет, что левая часть это проверяемое значение, а правая - ответ.

```js
assert(actual === expected);
```

Если используются другие операторы, то просто проверяется истинность выражения.

> Список таких операторов будет расширен.

Ключевое отличие от других систем утверждений заключается в том, что если утверждение неверно, то тест продолжает выполняться. Таким образом, если в тесте использовано множество утверждений, то можно увидеть результат по всем, а не только по первому. Чаще всего это дает более полное представление о проблеме.

### Исключения

Если возникает исключение, то выполнение теста прекращается. В этом случае можно увидеть на какой строке возникла проблема:

![Исключение](https://github.com/basisjs/test-runner/tree/master/docs/img/exception.png)

Иногда требуется проверить, что выполнение определенного кода должно приводит к исключению. В этом случае, такой код оборачивают в функцию и передают ее методу `assert.exception` или его синониму `assert.throws`.

```js
var foo = 123;

assert.exception(function(){
  foo.exception();
});
```

Если исключение будет выброшено, то утвержение будет считаться верным. Иначе будет считаться ошибкой. При возникновении исключения внутри функции обернутой `assert.exception` выполнение остального кода теста продолжается.

### Асинхронные тесты

Для написания асинхронных тестов, есть несколько возможностей.

Во-первых, в описании функции теста можно указать аргумент (его имя может быть любым), чьим его значением будет функция. Пока не будет вызвана эта функция, тест будет считаться выполняющимся.

```js
module.exports = {
  name: 'Async test',
  test: function(done){
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function(){
      if (xhr.readyState == 4)
      {
        assert(xhr.status === 200);
        done();
      }
    };
    xhr.open('GET', 'file.txt', true);
    xhr.send();
  }
};
```

Для выполнения асинхронных проверок не рекомендуется использовать `setTimeout` или `setInterval`. Для это нужно использовать метод `assert.async`, которому передается функция для выполнения в следующем фрейме. Внутри таких функций так же может быть вызван метод `assert.async`. Тест считается выполняющимся пока не выполнена хотя бы одна функция, заданная через `assert.async`.

Можно использоваит `assert.async` совместно с `done`. При этом тест будет считаться выполенным, когда выполнены все функции заданные через `assert.async` и выполнена функция `done`.

Если в ходе выполнения кода теста, возникает исключение, то выполенение теста прекращается, а еще не выполненные функции, выставленные через `assert.async`, вызваны не будут.

Каждому тесту, если он выполняется асинхронно, отводится 250ms. Это значение можно изменить на уровне теста, задав свойство `timeout` с необходимым значением. Если по истечении этого времени все еще будут не выполнены часть функций, то 

### Результат тестов

Тест считается пройденым, если все утверждения верны. 

Если тест не содержит утверждений, то он считается пропущенным (`pending`) вне зависимости от того какой код в нем выполняется. Также можно пропустить выполнение теста или пакет, задав свойство `pending` равным `true`.

Набор тестов считается пройденым, если среди его тестов нет ни одного с ошибкой, и есть хотя бы один успешный.

Примеры различных ситуаций и варианты отображения, можно найти например в `example/showcase.html`.

![Пример различных ситуаций](https://github.com/basisjs/test-runner/tree/master/docs/img/showcase.png)
